use std::env;
use std::fs;
use std::io;
use std::path::Path;
use std::process::{Command, Output};

use replicate::command_prelude::{App, Arg, SubCommand};
use replicate::util::{fail_loudly_then_exit, replicate_io};
use replicate::{ReplicateError, Result};

const REPLICATE_APPNAME: &str = "REPLICATE_APPNAME";

/// Constructs an `App` that is a `SubCommand::with_name` **init**.
pub fn cli() -> App {
    SubCommand::with_name("cli")
        .about("Replicates a general purpose cli.")
        .arg(
            Arg::with_name("name")
                .help("The name of the cli application")
                .required(true),
        )
}

/// Calls `init` to execute the init-command's functionality.
pub fn exec(app: String) -> Result<()> {
    init(app)
}

/// Initializes and creates the command line `app`lication by calling
/// `cargo new {app}`, then restructuring the results of that
/// operation.
///
/// If the call to `cargo new {app}` succeeds, then the results
/// of the operation (i.e. the contents, directory structure,
/// generated by calling `cargo new {app}`) are `restructured`.
///
/// Otherwise, this function _fails loudly_ by printing an error message
/// to a user's stderr before exiting.
fn init(app: String) -> Result<()> {
    match call_cargo_new(&app) {
        Ok(output) => {
            if output.status.success() {
                // `cargo new {app}` succeed, set the REPLICATE_APPNAME
                // environment variable to be `app` to be used later
                // without having to carry around a string everywhere.
                let app_name = up_case_first_char(app.clone());
                env::set_var(REPLICATE_APPNAME, &app_name);
                restructure_app(app)
            } else {
                fail_loudly_then_exit(format!(
                    "error: call to `cargo new {}` failed, exiting...",
                    &app
                ))
            }
        }
        Err(e) => Err(ReplicateError::Io(e)),
    }
}

/// Calls `cargo new {app}` in the directory in which replicate was invoked.
fn call_cargo_new(app: &str) -> io::Result<Output> {
    Command::new("cargo").arg("new").arg(app).output()
}

/// Restructures the results of calling `cargo new {app}`.
///
/// The bulk of the restructuring occurs in the crate's src directory.
/// This function determines the current directory (where replicate was invoked)
/// and then changes the current directory to src.
///
/// Once within the src directory the main.rs file created by `cargo new {app}`
/// is removed. Then the bin and lib subdirectories are created (and populated
/// with their appropriate contents).
///
/// Finally, the cargo manifest (Cargo.toml) is updated to reflect the changes
/// before returning to the directory from which `replicate init {app}` was
/// envoked.
fn restructure_app(app: String) -> Result<()> {
    // Determine the current directory, so that we can return to it later.
    let current_dir = env::current_dir()?;
    // Most of the restructuring takes place inside the src directory.
    let src = current_dir.join(&app).join("src");
    // Set the src directory to be the current directory.
    env::set_current_dir(&src)?;
    // Remove the old main.rs file.
    replicate_io::remove_file(src.join("main.rs"))?;
    // Create the bin subdirectory and populate it with its contents.
    create_bin(&app)?;
    // Create the lib subdirectory and populate it with its contents.
    create_lib(&app)?;
    // Update the cargo toml manifest to reflect the changes made.
    update_cargo_toml(current_dir.join(&app).join("Cargo.toml"))?;
    // Return to the directory from which `restructure_app` was originally
    // invoked.
    env::set_current_dir(&current_dir)?;
    Ok(())
}

/// Creates the bin subdirectory and populates it.
fn create_bin(app: &str) -> Result<()> {
    let bin = Path::new("bin").join(&app);
    fs::create_dir_all(&bin)?;
    populate_bin(&bin)?;
    Ok(())
}

/// Populates the bin subdirectory.
fn populate_bin<P: AsRef<Path>>(path: P) -> Result<()> {
    write_main_rs(path.as_ref())?;
    write_cli_rs(path.as_ref())?;
    create_commands(path.as_ref())?;
    Ok(())
}

fn write_main_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let main = path.as_ref().join("main.rs");
    let app_name = get_app_name();
    let contents = format!(
        r#"use std::process::exit;

use {AppName}::Result;

// Module Declarations.
mod cli;
mod commands;

fn main() -> Result<()> {{
    Ok(run(cli::app())?)
}}

/// Executes a cli app. This function parses the command line arguments and
/// maps a given command to _its_ executor.
fn run(app: clap::App<'static, 'static>) -> Result<()> {{
    match app.get_matches().subcommand() {{
        _ => {{
            exit(1);
        }}
    }}
}}
"#,
        AppName = app_name
    );

    Ok(replicate_io::write(&main, contents.as_bytes())?)
}

fn write_cli_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let cli = path.as_ref().join("cli.rs");
    let app_name = get_app_name();
    let contents = format!(
        r#"//! # Generates the top-level cli.
use crate::commands;
use {AppName}::command_prelude::*;

/// Builds an `App`. This `App` is comprised of information read from cargo
/// environment variables, a list of settings, and a list of a list of all
/// supported sub-commands.
pub fn app() -> App {{
    App::new(env!("CARGO_PKG_NAME"))
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about(env!("CARGO_PKG_DESCRIPTION"))
        .settings(&[
            AppSettings::UnifiedHelpMessage,
            AppSettings::DeriveDisplayOrder,
            AppSettings::VersionlessSubcommands,
            AppSettings::AllowExternalSubcommands,
            AppSettings::SubcommandRequiredElseHelp,
        ])
        .subcommands(commands::all_sub_commands())
}}
"#,
        AppName = app_name
    );
    Ok(replicate_io::write(&cli, contents.as_bytes())?)
}

fn create_commands<P: AsRef<Path>>(path: P) -> Result<()> {
    let commands = path.as_ref().join("commands");
    fs::create_dir_all(&commands)?;
    write_commands_mod_rs(commands.join("mod.rs"))?;
    write_command_init_rs(commands.join("init.rs"))?;
    Ok(())
}

fn write_commands_mod_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let app_name = get_app_name();
    let contents = format!(
        r#"use {AppName}::command_prelude::*;

pub fn all_sub_commands() -> Vec<App> {{
    vec![init::cli()]
}}

pub mod init;
"#,
        AppName = app_name
    );
    Ok(replicate_io::write(path.as_ref(), contents.as_bytes())?)
}

fn write_command_init_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let app_name = get_app_name();
    let contents = format!(
        r#"use {AppName}::command_prelude::{{App, Arg, SubCommand}};

pub fn cli() -> App {{
    SubCommand::with_name("init")
        .about("Example init command.")
        .arg(
            Arg::with_name("name")
                .help("The name of argument to init.")
                .required(true),
        )
}}"#,
        AppName = app_name
    );
    Ok(replicate_io::write(path.as_ref(), contents.as_bytes())?)
}

/// Creates the lib subdirectory and populates it.
fn create_lib(app: &str) -> Result<()> {
    let lib = Path::new(&app);
    fs::create_dir_all(&lib)?;
    populate_lib(&lib)?;
    Ok(())
}

/// Populates the lib subdirectory.
fn populate_lib<P: AsRef<Path>>(path: P) -> Result<()> {
    write_lib_rs(path.as_ref())?;
    write_util(path.as_ref())?;
    Ok(())
}

/// Writes contents to lib.rs.
fn write_lib_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let lib = path.as_ref().join("lib.rs");
    let app_name = get_app_name();
    let contents = format!(
        r#"// Module declarations.
pub mod util;

/// Re-exports.
pub use util::command_prelude;

pub use util::errors::{{ {AppName}Error, Result}};
"#,
        AppName = app_name
    );
    Ok(replicate_io::write(&lib, contents.as_bytes())?)
}

/// Creates and populates the util subdirectory.
fn write_util<P: AsRef<Path>>(path: P) -> Result<()> {
    let util = path.as_ref().join("util");
    fs::create_dir_all(&util)?;
    populate_util(&util)?;
    Ok(())
}

/// Populates the util subdirectory.
fn populate_util<P: AsRef<Path>>(path: P) -> Result<()> {
    write_util_mod_rs(&path)?;
    write_command_prelude_rs(&path)?;
    write_errors_rs(&path)?;
    Ok(())
}

fn write_util_mod_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let mod_rs = path.as_ref().join("mod.rs");
    let contents = r#"/// Utility module declarations.
pub mod command_prelude;
pub mod errors;
"#;

    Ok(replicate_io::write(&mod_rs, contents.as_bytes())?)
}

fn write_command_prelude_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let prelude = path.as_ref().join("command_prelude.rs");
    let contents = r#"/// Re-exporting `std::process`.
pub use std::process;

/// Re-exporting commonly necessary types from [`clap`].(https://github.com/clap-rs/clap)
pub use clap::{AppSettings, Arg, ArgMatches, SubCommand};

/// Type alias for a `clap::App`.
pub type App = clap::App<'static, 'static>;
"#;

    Ok(replicate_io::write(&prelude, contents.as_bytes())?)
}

fn write_errors_rs<P: AsRef<Path>>(path: P) -> Result<()> {
    let errors = path.as_ref().join("errors.rs");
    let app_name = get_app_name();
    let contents = format!(
        r#"//! Primary error structures for {AppName}.
use std::io;

/// Error types for {AppName}.
#[derive(Debug)]
pub enum {AppName}Error {{
    Io(io::Error),
}}

impl From<io::Error> for {AppName}Error {{
    fn from(err: io::Error) -> {AppName}Error {{
        {AppName}Error::Io(err)
    }}
}}

/// Custom result type for {AppName}.
pub type Result<T> = std::result::Result<T, {AppName}Error>;
"#,
        AppName = app_name
    );
    Ok(replicate_io::write(&errors, contents.as_bytes())?)
}

fn update_cargo_toml<P: AsRef<Path>>(path: P) -> Result<()> {
    let app_name = get_app_name();
    let contents = format!(
        r#"# replicate aims to be reasonably generic, if you want
# to use a specific version of clap, you should change the
# following to that version (e.g. clap = "2.33.0").
clap = "*"

[lib]
name = "{AppName}"
path = "src/{AppName}/lib.rs"
"#,
        AppName = app_name
    );

    if fs::metadata(path.as_ref()).is_ok() {
        replicate_io::append(path.as_ref(), contents.as_bytes())?;
    } else {
        fail_loudly_then_exit(format!("error: failed to retrieve Cargo.toml"))?;
    }
    Ok(())
}

/// Gets the app name (that was set within a successful call to `init`)
/// from the environment. If, for some reason, the `REPLICATE_APPNAME` was
/// not set and we've gotten this far, this function returns a dummy value
/// and we let the user and compiler figure sort it out.
fn get_app_name() -> String {
    match env::var_os(REPLICATE_APPNAME) {
        Some(os) => os
            .to_str()
            .map(String::from)
            .unwrap_or(String::from("AppName")),
        None => String::from("AppName"),
    }
}

/// Converts the first `char` of a `String` to its uppercase equivalent.
/// However, as this function uses an iterator over `char` values, which are
/// represented by Unicode Scalar Values, this function is rather dumb. A better
/// implementation would take something like grapheme clusters into account.
fn up_case_first_char(name: String) -> String {
    let mut chars = name.chars();
    if let Some(c) = chars.next() {
        let mut upper = c.to_uppercase().to_string();
        upper.push_str(chars.as_str());
        return upper;
    }
    name
}
